function [pvalues_modchisquare,observed_chisquare,observed_count,observed_ratio,permuted_chisquare,permuted_count,permuted_ratio] = PermuteSignificantClusteringEffects(msig,modules,npermutations,pvalr,varargin)
%PermuteSignificantClusteringEffects will take a binarized matrix of signifiance
%tests (1 - significant, 0 - not significant) and determine whether those
%tests occur within/between specific communities (modules). A null model is
%generated by randomizing which tests are/are not significant
%
%USAGE: [pvalues_modchisquare,observed_chisquare,observed_count,observed_ratio,permuted_chisquare,permuted_count,permuted_ratio] = PermuteSignificantClusteringEffects(msig,modules,npermutations,pvalr);
%
%INPUTS:
%
%   msig -- A binarized matrix for signifiant (1) and not significant (0)
%   events. Each row/column in the matrix reflects a single region of interest (ROI). 
%   Typically, a binarized matrix results from thresholding a
%   set of significance tests (e.g. t-test or pearson's correlation)
%
%   modules -- A 1-D matrix where the length of the matrix is the same size
%   as the number of ROIs in the binarized matrix. Each item in the matrix
%   is a number that represents the community assignment for the given ROI.
%   The order of items should match the order of the binarized matrix.
%
%   npermutations -- The number of permutations for generating the model.
%   The p value will be more precise with a larger number of permutations
%   -- literally the smallest p value is the inverse of the number
%   permutations -- but will also run more slowly. Rule of thumb is to perform as many as
%   you need -- typically 1,000 to 10,000 -- but no more than that.
%
%   pvalr -- The threshold for calculating the false-discovery rate for a
%   test. Typically this is set to 0.05/N, where N is the number of
%   matrices that are being clustered.
%
%   The optional inputs below may be put in any order. Each optional input
%   must be specified as a pair of inputs (e.g. if you want to include a
%   matrix of valid comparisons you need to add "
%   'ValidMatrix',validmatname)". Below are the current optional inputs:
%
%   *ValidMatrix* -- a logical or binarized matrix of the same size as msig
%   representing invalid (0) and valid (1) comparisons. Used to exclude
%   cells which cannot be measured in the first place.
%
%OUTPUTS:
%
%   pvalues_modchisquare -- a community X community X 2 matrix containing the
%   pvalues and the thresholded significant effects via false discovery
%   rate. The first sheet contains the p-values. The second sheet is a
%   matrix of ones, zeros, and negative ones, which represent significantly greater than chance (1), not
%   significant (0), or significnatly less than chance (-1).
%
%   observed_chisquare -- a community X community matrix containing the 
%   chisquare values for the modules.
%
%   observed_count -- a community X community X 4 matrix containing the
%   raw counts. The first sheet is the observed number of non-significant effects per
%   module. The second sheet is the observed number of significant effects per
%   module. The third sheet is the expected number of non-significant effects
%   per module. The fourth sheet is the expected number of significant
%   effects per module.
%
%   observed_ratio -- a community X community X 2 matrix containing the
%   proportion of significant/non-significant observations to all observations per module. The first
%   sheet reflects the proportion of non-significant observations to all observations.
%   The second sheet represents the proportion of significant observations
%   to all observations.
%
%   permuted_chisquare -- a community X community X npermutations matrix containing the 
%   chisquare values for the modules under the null model.
%
%   permuted_count -- a community X community X 4 X npermutations matrix containing the
%   raw counts.
%
%   permuted_ratio -- a community X community X 2 X npermutations matrix containing the
%   proportion of significant/non-significant observations to all observations per module.
%
%NOTES:
%  
%   The output matrices will be sorted in ascending numerical order. This
%   may not reflect the sorting you prefer, and you may have to re-sort the
%   matrix afterwards.
%
%SEE ALSO: CountSignificantEffectsByModules

%VERSION HISTORY%
%
%VERSION 1.1 --5/11/16
%   -Fixed code to work with new versions of matlab 2013+
%   - added documentation, 
%   -shifted outputs so that observed values can be output before permuted 
%   variables. Useful because the permuted variables can get very large.
%   
%VERSION 1.0 --4/30/14
%   Initialized but not documented by Eric Feczko
%
%
restrict_modules = 0;
for i = 1:size(varargin,2)
    if ischar(varargin{i})
        switch(varargin{i})
            case('ValidMatrix')
                restrict_modules = 1;
                validmat = varargin{i+1};
        end
    end
end
%if restricting modules, eliminate any significant effects found in these
%regions
if restrict_modules
    msig = msig.*validmat;
else
    validmat = logical(ones(size(msig,1),size(msig,2)));
end
number_of_nodes = size(msig,1);
moduleval = unique(modules);
if moduleval(1) == 0
    nummods = size(moduleval,1) - 1;
else
    nummods = size(moduleval,1);
end
if number_of_nodes ~= size(msig,2)
    nassignments = size(msig,2);
else
    nassignments = 0;
end
if nassignments == 0
    [observed_chisquare observed_count observed_ratio] = CountSignificantEffectsByModules(msig,modules,'ValidMatrix',validmat);
    observed_sigs = zeros(((number_of_nodes^2) - number_of_nodes)/2,1);
    observed_valids = ones(((number_of_nodes^2) - number_of_nodes)/2,1);
    count = 0;
    for i = 1:number_of_nodes-1
        for j = i+1:number_of_nodes
            count = count + 1;
            observed_sigs(count) = msig(i,j);
            observed_valids(count) = validmat(i,j);
        end
    end
    number_of_sigs = size(observed_sigs,1);
    permuted_chisquare = zeros(nummods,nummods,npermutations);
    permuted_count = zeros(nummods,nummods,4,npermutations);
    permuted_ratio = zeros(nummods,nummods,2,npermutations);
    for i = 1:npermutations
        fprintf('%s %i\n','permuting assignments for the groups: permutation #',i);
        rng('shuffle'); %regenerate the random number sequence
        temp_permute_sigs = zeros(number_of_sigs,1);
        valid_shuffle = find(observed_valids == 1);
        R = randperm(length(valid_shuffle));
        valids_only = observed_sigs(valid_shuffle);
        valids_shuffled = valids_only(R);
        temp_permute_sigs(valid_shuffle) = valids_shuffled;
        temp_permute_mat = zeros(number_of_nodes,number_of_nodes);
        count = 0;
        for k = 1:number_of_nodes-1
            for j = k+1:number_of_nodes
                count = count+1;
                temp_permute_mat(k,j) = temp_permute_sigs(count);
                temp_permute_mat(j,k) = temp_permute_sigs(count);
            end
        end
        [temp_chisquare temp_count temp_ratio] = CountSignificantEffectsByModules(temp_permute_mat,modules,'ValidMatrix',validmat);
        permuted_chisquare(:,:,i) = temp_chisquare;
        permuted_count(:,:,:,i) = temp_count;
        permuted_ratio(:,:,:,i) = temp_ratio;
    end
end
pvalues_modchisquare = zeros(nummods,nummods,2);
for i = 1:size(permuted_chisquare,1);
    for j = 1:size(permuted_chisquare,2);
        observed_val = observed_chisquare(i,j);
        temp_distribution = zeros(npermutations,1);
        temp_distribution(:,1) = permuted_chisquare(i,j,:);
        temp_distribution = sort(temp_distribution);
        high_tail = npermutations - max(find(temp_distribution <= observed_val));
        if isempty(high_tail)
            if isempty(find(temp_distribution <= observed_val));
                high_tail = 1;
            else
                high_tail = npermutations;
            end
        end
        low_tail = min(find(temp_distribution >= observed_val));
        if isempty(low_tail)
            if isempty(find(temp_distribution >= observed_val))
                low_tail = 1;
            else
                low_tail = npermutations;
            end
        end
        if high_tail == npermutations && low_tail ~= 1
            pvalues_modchisquare(i,j,1) = high_tail/npermutations;
        elseif low_tail == npermutations && high_tail ~= 1
            pvalues_modchisquare(i,j,1) = low_tail/npermutations;
        else
            if high_tail > low_tail
                pvalues_modchisquare(i,j,1) = low_tail/npermutations;
            else
                pvalues_modchisquare(i,j,1) = high_tail/npermutations;
            end
        end
    end
end
pvalues_list = zeros(nummods^2,1);
pvalues_list(:) = pvalues_modchisquare(:,:,1);
pvalues_list_sorted = sort(pvalues_list);
for i = 1:size(pvalues_list_sorted,1)
    if pvalues_list_sorted(i) == 0
        pvalues_list_sorted(i) = 1/npermutations; %if the observed value is beyond the permuted values, set it to the lowest possible p value we can measure
    end
end
pvalues_list_sorted = pvalues_list_sorted.*2;%for a two tailed test
pvalues_list_sorted = pvalues_list_sorted + 1/npermutations; %adjsut for the error in expected permutations
V = length(pvalues_list_sorted);
I = (1:V)';

cVID = 1;
cVN = sum(1./(1:V));

pID = pvalues_list_sorted(find(pvalues_list_sorted<=I/V*pvalr/cVID, 1, 'last' ))
if(size(pID,1) == 0)
    pID =pvalr;
    'no connections survive multiple comparison correction'
end
pN = pvalues_list_sorted(find(pvalues_list_sorted<=I/V*pvalr/cVN, 1, 'last' ))
if(size(pN,1) == 0)
    pN =0;
    'no connections survive multiple comparison correction'
end
pvalues_dist = zeros(nummods,nummods);
for i = 1:nummods
    for j = 1:nummods
        if observed_count(i,j,2) > observed_count(i,j,4)
            pvalues_dist(i,j) = 1;
        else
            pvalues_dist(i,j) = -1;
        end
    end
end
for i = 1:nummods
    for j = 1:nummods
        if pvalues_modchisquare(i,j,1) == 0
            pvalues_modchisquare(i,j,1) = (1/npermutations);
        end
        pvalues_modchisquare(i,j,1) = pvalues_modchisquare(i,j,1)*2; %for a two-tailed test
        if pvalues_modchisquare(i,j,1) <= pID
            pvalues_modchisquare(i,j,2) = 1*pvalues_dist(i,j);
        end
    end
end